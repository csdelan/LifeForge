@page "/"
@page "/character"
@using LifeForge.Domain
@using LifeForge.Web.Services
@using LifeForge.Web.Models
@inject CharacterService CharacterService
@inject BuffInstanceService BuffInstanceService
@inject ActionService ActionService
@inject IJSRuntime JSRuntime
@inject HttpClient HttpClient

<PageTitle>Character Sheet</PageTitle>

<div class="character-sheet">
    <h1>Character Sheet</h1>

    @if (showDebugTools)
    {
        <!-- Manual Buff Processing Trigger (Development Only) -->
        <div class="debug-section" style="margin-bottom: 1rem; padding: 1rem; background: #fff3cd; border-radius: 8px;">
            <button class="btn btn-warning" @onclick="TriggerBuffProcessing" disabled="@isProcessingBuffs">
                <span class="bi bi-lightning-charge"></span>
                @if (isProcessingBuffs)
                {
                    <span>Processing Buffs...</span>
                }
                else
                {
                    <span>? Manually Trigger Buff Processing</span>
                }
            </button>
            @if (!string.IsNullOrEmpty(buffProcessingMessage))
            {
                <div class="alert alert-info mt-2">@buffProcessingMessage</div>
            }
        </div>
    }

    @if (isLoading)
    {
        <p><em>Loading character...</em></p>
    }
    else if (_character != null)
    {
        <div class="character-info">
            <h2>@_character.Name</h2>

            <div class="stats-grid">
                <div class="stat-section">
                    <h3>Attributes</h3>
                    <div class="stat-row">
                        <span class="stat-label">Strength:</span>
                        <span class="stat-value">@_character.Strength</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Discipline:</span>
                        <span class="stat-value">@_character.Discipline</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Focus:</span>
                        <span class="stat-value">@_character.Focus</span>
                    </div>
                </div>

                <div class="stat-section">
                    <h3>Resources</h3>
                    <div class="resource-bar">
                        <label>HP @if (HasBuffModifiers()) { <small title="Base: @((int)_character.HP)">(Buffed)</small> }</label>
                        <div class="progress-bar">
                            <div class="progress-background hp-background"></div>
                            <div class="progress-fill hp-fill" style="width: @GetHPPercentage()%"></div>
                            <span class="progress-text">@((int)_character.EffectiveHP) / @((int)_character.EffectiveHPMax)</span>
                        </div>
                    </div>
                    <div class="resource-bar">
                        <label>MP @if (HasBuffModifiers()) { <small title="Base: @((int)_character.MP)">(Buffed)</small> }</label>
                        <div class="progress-bar">
                            <div class="progress-background mp-background"></div>
                            <div class="progress-fill mp-fill" style="width: @GetMPPercentage()%"></div>
                            <span class="progress-text">@((int)_character.EffectiveMP) / @((int)_character.EffectiveMPMax)</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="wealth-section">
                <h3>Wealth</h3>
                <div class="currency-list">
                    @if (_character.Currencies.Any())
                    {
                        @foreach (var currency in _character.Currencies)
                        {
                            <div class="currency-item">
                                <span class="currency-name">@currency.Key:</span>
                                <span class="currency-amount">@currency.Value</span>
                            </div>
                        }
                    }
                    else
                    {
                        <p class="no-data">No currencies yet</p>
                    }
                </div>
            </div>

            <div class="classes-section">
                <h3>Classes</h3>
                <div class="class-list">
                    @if (_character.ClassProfiles.Any())
                    {
                        @foreach (var classProfile in _character.ClassProfiles)
                        {
                            <div class="class-item">
                                <h4>@classProfile.Value.ClassName</h4>
                                <div class="class-details">
                                    <span>Level: @classProfile.Value.Level</span>
                                    <div class="xp-bar">
                                        <div class="progress-bar small">
                                            <div class="progress-fill xp-fill" style="width: @GetXPPercentage(classProfile.Value)%"></div>
                                            <span class="progress-text small">@classProfile.Value.CurrentXp / @classProfile.Value.XpToNextLevel</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    }
                    else
                    {
                        <p class="no-data">No classes yet</p>
                    }
                </div>
            </div>

            <div class="buffs-section">
                <h3>Active Buffs/Debuffs</h3>
                @if (isLoadingBuffs)
                {
                    <p><em>Loading active buffs...</em></p>
                }
                else if (displayBuffs.Any())
                {
                    <div class="active-buffs-gallery">
                        @foreach (var buffGroup in displayBuffs)
                        {
                            <div class="active-buff-card @(buffGroup.IsDebuff ? "debuff-card" : "buff-card")" 
                                 title="@GetBuffGroupTooltip(buffGroup)">
                                <div class="active-buff-image">
                                    @if (!string.IsNullOrEmpty(buffGroup.ImageData))
                                    {
                                        <img src="@GetImageDataUrl(buffGroup.ImageData, buffGroup.ImageContentType)" alt="@buffGroup.BuffName" />
                                    }
                                    else
                                    {
                                        <div class="active-buff-placeholder">
                                            <span class="bi @(buffGroup.IsDebuff ? "bi-arrow-down-circle" : "bi-arrow-up-circle")"></span>
                                        </div>
                                    }
                                    @if (buffGroup.TotalStacks > 1)
                                    {
                                        <div class="active-buff-stacks-badge">x@(buffGroup.TotalStacks)</div>
                                    }
                                </div>
                                <div class="active-buff-info">
                                    <div class="active-buff-name">@buffGroup.BuffName</div>
                                    <div class="active-buff-timer">
                                        <span class="bi bi-clock"></span>
                                        @GetBuffTimeRemaining(buffGroup.OldestEndTime)
                                    </div>
                                    @if (buffGroup.HasPending)
                                    {
                                        <div class="buff-status-badge pending">@buffGroup.PendingCount Pending</div>
                                    }
                                </div>
                                <button class="btn-end-buff" @onclick="() => RemoveOneStack(buffGroup)" title="Remove 1 Stack">
                                    <span class="bi bi-x-lg"></span>
                                </button>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <p class="no-data">No active buffs</p>
                }
            </div>

            <div class="actions-section">
                <h3>Common Actions</h3>
                <div class="actions-list">
                    <div class="action-item">
                        <div class="action-info">
                            <span class="action-icon">??</span>
                            <div class="action-details">
                                <div class="action-name">Drink Alcoholic Beverage</div>
                                <div class="action-description">Drink an alcoholic drink, resulting in Hangover and Alcohol Detoxing effects</div>
                            </div>
                        </div>
                        <button class="btn-execute-action" @onclick="DrinkAlcoholicDrink" disabled="@isPerformingAction" title="Execute this action">
                            <span class="bi bi-play-circle-fill"></span>
                            Execute
                        </button>
                    </div>
                </div>
            </div>
        </div>
    }
    else
    {
        <div class="alert alert-info">
            <h4><span class="bi bi-info-circle"></span> No Character Yet</h4>
            <p>Complete your first quest to create your character and start earning rewards!</p>
            <a href="/quests" class="btn btn-primary">Go to Quests</a>
        </div>
    }
</div>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger alert-dismissible fade show mt-3" role="alert">
        @errorMessage
        <button type="button" class="btn-close" @onclick="() => errorMessage = null"></button>
    </div>
}

@if (!string.IsNullOrEmpty(successMessage))
{
    <div class="alert alert-success alert-dismissible fade show mt-3" role="alert">
        @successMessage
        <button type="button" class="btn-close" @onclick="() => successMessage = null"></button>
    </div>
}

@code {
    private Models.CharacterDto? _character;
    private List<BuffInstanceDto> activeBuffs = new();
    private List<BuffDisplayGroup> displayBuffs = new();
    private bool isLoading = true;
    private bool isLoadingBuffs = true;
    private bool isPerformingAction = false;
    private bool isProcessingBuffs = false;
    private string? errorMessage;
    private string? successMessage;
    private string? buffProcessingMessage;

    // Show debug tools - set to true for development, false for production
    // In WASM, we can't easily detect environment, so we use a constant
    private const bool showDebugTools = true; // Set to false before production deploy

    // Helper class to group buff instances for display
    private class BuffDisplayGroup
    {
        public string BuffId { get; set; } = string.Empty;
        public string BuffName { get; set; } = string.Empty;
        public bool IsDebuff { get; set; }
        public string? ImageData { get; set; }
        public string? ImageContentType { get; set; }
        public string? Description { get; set; }
        public int TotalStacks { get; set; }
        public int ActiveStacks { get; set; }
        public int PendingCount { get; set; }
        public bool HasPending => PendingCount > 0;
        public DateTime OldestEndTime { get; set; }
        public List<BuffInstanceDto> Instances { get; set; } = new();
        
        // Modifiers (from first instance, they should all be the same)
        public int HPModifier { get; set; }
        public int HPMaxModifier { get; set; }
        public int HPPercentModifier { get; set; }
        public int HPMaxPercentModifier { get; set; }
        public int MPModifier { get; set; }
        public int MPMaxModifier { get; set; }
        public int MPPercentModifier { get; set; }
        public int MPMaxPercentModifier { get; set; }
        public int XpGainsPercentModifier { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadCharacter();
        await LoadActiveBuffs();
    }

    private async Task LoadCharacter()
    {
        try
        {
            isLoading = true;
            _character = await CharacterService.GetCharacterAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"No character found: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task LoadActiveBuffs()
    {
        try
        {
            isLoadingBuffs = true;
            if (_character != null && !string.IsNullOrEmpty(_character.Id))
            {
                activeBuffs = await BuffInstanceService.GetActiveBuffInstancesByCharacterIdAsync(_character.Id);
                
                // Group buffs by BuffId for display
                displayBuffs = activeBuffs
                    .GroupBy(b => b.BuffId)
                    .Select(g =>
                    {
                        var first = g.First();
                        var activeInstances = g.Where(b => b.Status == BuffInstanceStatus.Active).ToList();
                        var pendingInstances = g.Where(b => b.Status == BuffInstanceStatus.Pending).ToList();
                        
                        return new BuffDisplayGroup
                        {
                            BuffId = g.Key,
                            BuffName = first.BuffName,
                            IsDebuff = first.IsDebuff,
                            ImageData = first.ImageData,
                            ImageContentType = first.ImageContentType,
                            Description = first.Description,
                            TotalStacks = g.Sum(b => b.Stacks),
                            ActiveStacks = activeInstances.Sum(b => b.Stacks),
                            PendingCount = pendingInstances.Count,
                            OldestEndTime = g.Min(b => b.EndTime),
                            Instances = g.ToList(),
                            HPModifier = first.HPModifier,
                            HPMaxModifier = first.HPMaxModifier,
                            HPPercentModifier = first.HPPercentModifier,
                            HPMaxPercentModifier = first.HPMaxPercentModifier,
                            MPModifier = first.MPModifier,
                            MPMaxModifier = first.MPMaxModifier,
                            MPPercentModifier = first.MPPercentModifier,
                            MPMaxPercentModifier = first.MPMaxPercentModifier,
                            XpGainsPercentModifier = first.XpGainsPercentModifier
                        };
                    })
                    .ToList();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading active buffs: {ex.Message}");
        }
        finally
        {
            isLoadingBuffs = false;
        }
    }

    private async Task RemoveOneStack(BuffDisplayGroup buffGroup)
    {
        // Only remove one stack at a time
        var confirmMessage = buffGroup.Instances.Count > 1 
            ? $"Remove 1 stack of '{buffGroup.BuffName}'? ({buffGroup.Instances.Count} total instances)"
            : $"Remove '{buffGroup.BuffName}'?";
            
        if (!await JSRuntime.InvokeAsync<bool>("confirm", confirmMessage))
        {
            return;
        }

        try
        {
            // Remove only the oldest instance (FIFO - First In, First Out)
            var oldestInstance = buffGroup.Instances.OrderBy(i => i.StartTime).First();
            
            await BuffInstanceService.DeactivateBuffInstanceAsync(_character!.Id!, oldestInstance.Id!);

            var remaining = buffGroup.Instances.Count - 1;
            successMessage = remaining > 0 
                ? $"Removed 1 stack of '{buffGroup.BuffName}' ({remaining} remaining)"
                : $"Removed '{buffGroup.BuffName}'";
                
            await LoadCharacter();
            await LoadActiveBuffs();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error ending buff: {ex.Message}";
        }
    }

    private async Task DrinkAlcoholicDrink()
    {
        if (_character == null || string.IsNullOrEmpty(_character.Id))
        {
            errorMessage = "No character found";
            return;
        }

        try
        {
            isPerformingAction = true;
            
            var buffService = new BuffService(new HttpClient { BaseAddress = new Uri("https://localhost:7001") });
            var allBuffs = await buffService.GetAllBuffsAsync();
            
            var hangoverBuff = allBuffs.FirstOrDefault(b => b.Name == "Hangover");
            var detoxBuff = allBuffs.FirstOrDefault(b => b.Name == "Alcohol Detoxing");
            
            if (hangoverBuff == null || detoxBuff == null)
            {
                errorMessage = "Required buffs (Hangover and Alcohol Detoxing) not found. Please create them first.";
                return;
            }

            var hangoverResult = await BuffInstanceService.ActivateBuffAsync(_character.Id, hangoverBuff.Id!);
            var detoxResult = await BuffInstanceService.ActivateBuffAsync(_character.Id, detoxBuff.Id!);

            if (hangoverResult?.Success == true && detoxResult?.Success == true)
            {
                successMessage = "?? You drank an alcoholic beverage! Effects: Hangover and Alcohol Detoxing activated.";
                await LoadCharacter();
                await LoadActiveBuffs();
            }
            else
            {
                errorMessage = "Failed to apply drinking effects. " + (hangoverResult?.ErrorMessage ?? detoxResult?.ErrorMessage ?? "");
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error performing action: {ex.Message}";
        }
        finally
        {
            isPerformingAction = false;
        }
    }

    private string GetBuffTimeRemaining(DateTime endTime)
    {
        var remaining = endTime - DateTime.UtcNow;
        if (remaining.TotalDays >= 1)
            return $"{(int)remaining.TotalDays}d";
        if (remaining.TotalHours >= 1)
            return $"{(int)remaining.TotalHours}h";
        if (remaining.TotalMinutes >= 1)
            return $"{(int)remaining.TotalMinutes}m";
        return "Expiring soon";
    }

    private string GetBuffGroupTooltip(BuffDisplayGroup buffGroup)
    {
        var tooltip = new System.Text.StringBuilder();
        tooltip.AppendLine(buffGroup.BuffName);
        
        if (!string.IsNullOrEmpty(buffGroup.Description))
        {
            tooltip.AppendLine();
            tooltip.AppendLine(buffGroup.Description);
        }
        
        var stacks = buffGroup.TotalStacks;
        var modifiers = new List<string>();
        
        if (buffGroup.HPModifier != 0)
            modifiers.Add($"HP {FormatModifier(buffGroup.HPModifier * stacks)} (per stack: {FormatModifier(buffGroup.HPModifier)})");
        if (buffGroup.HPMaxModifier != 0)
            modifiers.Add($"HP Max {FormatModifier(buffGroup.HPMaxModifier * stacks)} (per stack: {FormatModifier(buffGroup.HPMaxModifier)})");
        if (buffGroup.HPPercentModifier != 0)
            modifiers.Add($"HP {FormatModifier(buffGroup.HPPercentModifier * stacks)}% (per stack: {FormatModifier(buffGroup.HPPercentModifier)}%)");
        if (buffGroup.HPMaxPercentModifier != 0)
            modifiers.Add($"HP Max {FormatModifier(buffGroup.HPMaxPercentModifier * stacks)}% (per stack: {FormatModifier(buffGroup.HPMaxPercentModifier)}%)");
        if (buffGroup.MPModifier != 0)
            modifiers.Add($"MP {FormatModifier(buffGroup.MPModifier * stacks)} (per stack: {FormatModifier(buffGroup.MPModifier)})");
        if (buffGroup.MPMaxModifier != 0)
            modifiers.Add($"MP Max {FormatModifier(buffGroup.MPMaxModifier * stacks)} (per stack: {FormatModifier(buffGroup.MPMaxModifier)})");
        if (buffGroup.MPPercentModifier != 0)
            modifiers.Add($"MP {FormatModifier(buffGroup.MPPercentModifier * stacks)}% (per stack: {FormatModifier(buffGroup.MPPercentModifier)}%)");
        if (buffGroup.MPMaxPercentModifier != 0)
            modifiers.Add($"MP Max {FormatModifier(buffGroup.MPMaxPercentModifier * stacks)}% (per stack: {FormatModifier(buffGroup.MPMaxPercentModifier)}%)");
        if (buffGroup.XpGainsPercentModifier != 0)
            modifiers.Add($"XP Gains {FormatModifier(buffGroup.XpGainsPercentModifier * stacks)}% (per stack: {FormatModifier(buffGroup.XpGainsPercentModifier)}%)");
        
        if (modifiers.Any())
        {
            tooltip.AppendLine();
            if (stacks > 1)
            {
                tooltip.AppendLine($"Total Modifiers (x{stacks} stacks):");
            }
            else
            {
                tooltip.AppendLine("Modifiers:");
            }
            foreach (var modifier in modifiers)
            {
                tooltip.AppendLine($"  {modifier}");
            }
        }
        
        if (buffGroup.TotalStacks > 1)
        {
            tooltip.AppendLine();
            tooltip.AppendLine($"Active Instances: {buffGroup.Instances.Count}");
            tooltip.AppendLine($"Total Stacks: {buffGroup.TotalStacks}");
            if (buffGroup.HasPending)
            {
                tooltip.AppendLine($"Pending: {buffGroup.PendingCount}");
            }
        }
        
        return tooltip.ToString().TrimEnd();
    }

    private string FormatModifier(int value)
    {
        return value > 0 ? $"+{value}" : value.ToString();
    }

    private string GetImageDataUrl(string? imageData, string? contentType)
    {
        if (string.IsNullOrEmpty(imageData))
            return string.Empty;
        
        var mimeType = !string.IsNullOrEmpty(contentType) ? contentType : "image/jpeg";
        return $"data:{mimeType};base64,{imageData}";
    }

    private bool HasBuffModifiers()
    {
        if (_character == null) return false;
        var mods = _character.ActiveBuffModifiers;
        return mods.HPModifier != 0 || mods.HPMaxModifier != 0 || mods.HPPercentModifier != 0 ||
               mods.HPMaxPercentModifier != 0 || mods.MPModifier != 0 || mods.MPMaxModifier != 0 ||
               mods.MPPercentModifier != 0 || mods.MPMaxPercentModifier != 0;
    }

    private async Task TriggerBuffProcessing()
    {
        try
        {
            isProcessingBuffs = true;
            buffProcessingMessage = "Triggering buff processing...";
            StateHasChanged();

            var response = await HttpClient.PostAsync("api/buffprocessing/trigger", null);
            
            if (response.IsSuccessStatusCode)
            {
                buffProcessingMessage = "? Buff processing completed successfully! Reloading character...";
                await Task.Delay(500);
                await LoadCharacter();
                await LoadActiveBuffs();
                successMessage = "Buff processing completed!";
            }
            else
            {
                buffProcessingMessage = "? Failed to process buffs";
                errorMessage = "Failed to trigger buff processing";
            }
        }
        catch (Exception ex)
        {
            buffProcessingMessage = $"? Error: {ex.Message}";
            errorMessage = $"Error triggering buff processing: {ex.Message}";
        }
        finally
        {
            isProcessingBuffs = false;
            StateHasChanged();
        }
    }

    private double GetHPPercentage()
    {
        if (_character == null || _character.EffectiveHPMax == 0) return 0;
        return (double)(_character.EffectiveHP / _character.EffectiveHPMax) * 100;
    }

    private double GetMPPercentage()
    {
        if (_character == null || _character.EffectiveMPMax == 0) return 0;
        return (double)(_character.EffectiveMP / _character.EffectiveMPMax) * 100;
    }

    private double GetXPPercentage(Models.CharacterClassDto classSnapshot)
    {
        if (classSnapshot.XpToNextLevel == 0) return 100;
        return ((double)classSnapshot.CurrentXp / classSnapshot.XpToNextLevel) * 100;
    }
}
